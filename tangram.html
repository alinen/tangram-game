<html>
<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
}

#container {
  position: relative;
  width: 100vw;
  height: 100vh;
}

#svgObject, #overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

#overlay {
  pointer-events: none; /* clicks go to SVG */
}
</style>
<body>

<div id="container">
  <object id="svgObject" 
          data="puzzle-rocket.svg" 
          type="image/svg+xml" 
          preserveAspectRatio="xMidYMid meet"
          onload="start()">
  </object>
  <canvas id="overlay"></canvas>
</div>

<script>
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
var svgDoc = null;

var gameOverMessage = "You win!";
var gameOver = false;

var selectedPiece = null;
function mouseClick(piece, e) {
  console.log("CLICK Client", e.clientX, e.clientY);
  console.log("CLICK Offset", e.offsetX, e.offsetY);
  console.log("CLICK Scrren", e.screenX, e.screenY);
  if (selectedPiece == null) selectedPiece = piece;
  else {
    selectedPiece = null;
  }
}

function mouseMove(piece, e) {
  //console.log(e.offsetX, e.offsetY);
  const svg = svgDoc.querySelector("svg");
  var vb = svg.viewBox.baseVal;
  var x = e.offsetX * vb.width / canvas.width;
  var y = e.offsetY * vb.height / canvas.height;
  if (selectedPiece != null) selectedPiece.translate(x, y); //piece.startx, piece.starty);
}

class PuzzlePiece
{
  constructor(svgElement)
  {
    this.el = svgElement;
    this.bbox = this.el.getBBox();     
    this.startx = this.bbox.x;
    this.starty = this.bbox.y;

    this.el.addEventListener("mousemove", e => { mouseMove(this, e); });
    this.el.addEventListener("click", e => { mouseClick(this, e); });
    //console.log("puzzle piece:" + this.el.id);
    //console.log(`puzzle bbox: ${this.bbox.x} ${this.bbox.y} ${this.bbox.width} ${this.bbox.height}`);
  }

  translate(x, y) {
    x = x - this.el.getBBox().x;
    y = y - this.el.getBBox().y;
    var attrval =  `translate(${x} ${y})`;
    this.el.setAttribute("transform", attrval);
  }
}
var puzzlePieces = [];

function start() {
  console.log("start");
  const obj = document.getElementById("svgObject");
  svgDoc = obj.contentDocument;
  if (!svgDoc) {
    console.logError("Error: No SVG document found.");
    return;
  }

  const svg = svgDoc.querySelector("svg");
  //const width = svg.viewBox.baseVal.width;
  //const height = svg.viewBox.baseVal.height;
  //Math.floor(Math.random() * 2); 

  var idx = 0; 
  var x = 200;
  var y = 25;
  var maxsize = 0;
  const puzzleLayer = svgDoc.getElementById("PuzzleLayer");
  for (const el of puzzleLayer.children) {
    var piece = new PuzzlePiece(el);
    piece.translate(x, y);
    puzzlePieces.push(piece);
    //console.log(`${el.id} ${i} ${j} ${x} ${y}`);

    x = x + piece.bbox.width + 10;
    if (maxsize < piece.bbox.height) maxsize = piece.bbox.height;

    idx = idx + 1;
    if (idx % 4 == 0) {
      y = y + maxsize + 10;
      x = 200;
    }
  }
}

function resize() {
  canvas.width  = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  draw();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (gameOver)
  {
    ctx.font = "64px Arial";
    ctx.textAlign = "center";
    ctx.lineWidth = 2;
    ctx.fillStyle = "red";
    ctx.strokeStyle = "black";
    ctx.fillText(gameOverMessage, canvas.width/2, canvas.height/2);
    ctx.strokeText(gameOverMessage, canvas.width/2, canvas.height/2);
  }
}

window.addEventListener("resize", resize);
resize();
</script>


</body>
</html>