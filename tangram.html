<html>
<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
}

#container {
  position: absolute;
  width: 100vw;
  height: 100vh;
}

#svgObject, #overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

#overlay {
  pointer-events: none; /* clicks go to SVG */
}
</style>
<body>

<div id="container">
  <object id="svgObject" 
          data="puzzle-rocket.svg" 
          type="image/svg+xml" 
          preserveAspectRatio="xMidYMid meet"
          onload="start()">
  </object>
  <canvas id="overlay"></canvas>
</div>

<script>
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
var svg = null;

var gameOverMessage = "You win!";
var gameOver = false;

var selectedPiece = null;
var selectedOffsetX = 0;
var selectedOffsetY = 0;
var puzzlePieces = [];
var threshold = 10; // pixels in svg space
var duration = 60; // seconds

function client2svg(px, py) {
  var vb = svg.viewBox.baseVal;
  var scaledHeight = (vb.height / vb.width) * canvas.width;
  var x = (px / canvas.width) * vb.width;
  var y = (py - (canvas.height - scaledHeight) / 2) / scaledHeight * vb.height;
  return {x: x, y: y};
}

class PuzzlePiece
{
  constructor(svgElement)
  {
    this.el = svgElement;
    
    // Assert that there are no transforms on this puzzle piece 
    // Matrix transformations are not currently supported
    const transformList = this.el.transform.baseVal;
    if (transformList.numberOfItems == 0) {
      console.error("ERROR: Unsuppported transform type in puzzle piece.");
    }
  
    // Initialize polygon points for intersection tests
    // Assume all paths are closed
    this.points = []

    var i = 0;
    var mode = '\0'; 
    const supportedOptions = ["m", "M", "l", "L", "h", "H", "v", "V", "z", "Z"];
    const path = this.el.getAttribute("d").replaceAll(",", " ");
    const tokens = path.split(" ");
    while (i < tokens.length) {
      if (supportedOptions.includes(tokens[i])) {
        mode = tokens[i++];
      }
      else if (["m", "M", "l", "L"].includes(mode)) { // two values
        var x = Number(tokens[i++]);
        var y = Number(tokens[i++]);
        if (this.points.length == 0 || mode == "M" || mode == "L") { // absolute
          this.points.push({x: x, y: y});
        }      
        else if (mode == "m" || mode == "l") { // relative
          var lastp = this.points[this.points.length-1];
          this.points.push({x: lastp.x + x, y: lastp.y + y});
        }
      }
      else if (["h", "H", "v", "V"]) { // single value
        var lastp = this.points[this.points.length-1];
        var u = Number(tokens[i++]);
        if (mode == "h") {
          this.points.push({x: lastp.x + u, y: lastp.y});
        }
        else if (mode == "H") {
          this.points.push({x: u, y: lastp.y});
        }
        else if (mode == "v") {
          this.points.push({x: lastp.x, y: lastp.y + u});
        }
        else if (mode == "V") {
          this.points.push({x: lastp.x, y: u});
        }
      }
      else console.error("Unsupported path format:", path);
    }

    console.log("===== ", this.el.id, "=========");
    var newPath = "M ";
    this.x = this.el.getBBox().x;
    this.y = this.el.getBBox().y;
    for (var i = 0; i < this.points.length; i++) {
      this.points[i].x -= this.x;
      this.points[i].y -= this.y;
      newPath += `${this.points[i].x} ${this.points[i].y} `
      console.log(this.points[i].x, this.points[i].y);
    }
    newPath += "Z";
    this.el.setAttribute("d", newPath);

    // Save width and height for positioning logic
    this.width = this.el.getBBox().width;
    this.height = this.el.getBBox().height;

    // Use starting positions to detect win state
    this.startx = this.x;
    this.starty = this.y;
    
    this.translate(this.x, this.y);
    //console.log("puzzle piece:" + this.el.id);
    //console.log(`puzzle bbox: ${this.bbox.x} ${this.bbox.y} ${this.bbox.width} ${this.bbox.height}`);
  }

  translate(x, y) { // in svg coordinates, e.g. (0,0, width, height)
    this.x = x;
    this.y = y;
    var attrval =  `translate(${x} ${y})`;
    this.el.setAttribute("transform", attrval);
  }

  closeTo(pos, x, y) {
    var dSqr = (pos.x - x)*(pos.x - x) + (pos.y - y)*(pos.y - y);
    return dSqr < threshold * threshold;
  }

  transformPoint(p) {
    // NOTE: matrix is not needed if we ensure no rotations/skew in pieces
    //var x = matrix.a * p.x + matrix.b * p.y + matrix.e;
    //var y = matrix.c * p.x + matrix.d * p.y + matrix.f;
    return {x: p.x + this.x, y: p.y + this.y};
  }

  checkTriangleIntersection(pos, p1, p2, p3) {
    // computer barycentric coordinates
    var lamnum1 = (p2.y - p3.y) * (pos.x - p3.x) + (p3.x - p2.x) * (pos.y - p3.y);
    var denom = (p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y);
    var lam1 = lamnum1 / denom;
    if (lam1 < 0 || lam1 > 1) return false;

    var lamnum2 = (p3.y - p1.y) * (pos.x - p3.x) + (p1.x - p3.x) * (pos.y - p3.y);
    var lamdom2 = (p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y);
    var lam2 = lamnum2 / denom;
    if (lam2 < 0 || lam2 > 1) return false;

    var lam3 = 1 - lam1 - lam2;
    if (lam3 < 0 || lam3 > 1) return false;
    
    return true;
  }

  intersects(pos) { // in client coordinates

    //NOTE: const numTris = numVerts - 2;
    const numVerts = this.points.length;

    var p1 = this.transformPoint(this.points[0]);
    for (var i = 1; i < numVerts-1; i++) {
      var p2 = this.transformPoint(this.points[i+0]);
      var p3 = this.transformPoint(this.points[i+1]);
      if (this.checkTriangleIntersection(pos, p1, p2, p3)) return true;
    }    

    return false;
  }

  anchor() {
    const bbox = this.el.getBoundingClientRect();
    var svgpos = client2svg(bbox.x, bbox.y);

    if (this.closeTo(svgpos, this.startx, this.starty)) {
      this.translate(this.startx, this.starty);
    }
    else {
      const cellsize = 1;
      const half = cellsize * 0.5;
      var x = Math.floor(cellsize * ((svgpos.x + half)/ cellsize));
      var y = Math.floor(cellsize * ((svgpos.y + half)/ cellsize));
      this.translate(x, y);
    }
  }
}

function mouseClick(e) {
  if (selectedPiece != null) { // drop it
    selectedPiece.anchor();
    selectedPiece = null;
    return;
  }

  // pickup
  var clickPos = client2svg(e.clientX, e.clientY);
  var selected = null;
  for (var piece of puzzlePieces) {
    if (piece.intersects(clickPos)) {
      selectedOffsetX = piece.x - clickPos.x;
      selectedOffsetY = piece.y - clickPos.y;
      selected = piece;
      break;
    }
  }

  selectedPiece = selected; 
}

function mouseMove(e) {
  if (selectedPiece == null) return;

  // convert from client coordinates to SVG viewport coordinates
  var svgpos = client2svg(e.clientX, e.clientY);
  selectedPiece.translate(svgpos.x + selectedOffsetX, svgpos.y + selectedOffsetY); 
}

function start() {
  const obj = document.getElementById("svgObject");
  const svgDoc = obj.contentDocument;
  if (!svgDoc) {
    console.logError("Error: No SVG document found.");
    return;
  }

  svg = svgDoc.querySelector("svg");
  svg.addEventListener("mousemove", e => { mouseMove(e); });
  svg.addEventListener("click", e => { mouseClick(e); });

  //const width = svg.viewBox.baseVal.width;
  //const height = svg.viewBox.baseVal.height;
  //Math.floor(Math.random() * 2); 

  var idx = 0; 
  var x = 200;
  var y = 25;
  var maxsize = 0;
  const puzzleLayer = svgDoc.getElementById("PuzzleLayer");
  
  // assert that puzzle layer does not have a transform on it
  const transform = puzzleLayer.getAttribute("transform");
  if (transform != undefined) console.error("ERROR: Transform on puzzle layer is not supported");

  for (const el of puzzleLayer.children) {
    var piece = new PuzzlePiece(el);
    piece.translate(x, y);
    puzzlePieces.push(piece);
    console.log(`${el.id} ${x} ${y}`);

    x = x + piece.width + 10;
    if (maxsize < piece.height) maxsize = piece.height;

    idx = idx + 1;
    if (idx % 4 == 0) {
      y = y + maxsize + 10;
      x = 200;
    }
  }
}

function resize() {
  canvas.width  = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  draw();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (gameOver)
  {
    ctx.font = "64px Arial";
    ctx.textAlign = "center";
    ctx.lineWidth = 2;
    ctx.fillStyle = "red";
    ctx.strokeStyle = "black";
    ctx.fillText(gameOverMessage, canvas.width/2, canvas.height/2);
    ctx.strokeText(gameOverMessage, canvas.width/2, canvas.height/2);
  }
}

window.addEventListener("resize", resize);
resize();
</script>


</body>
</html>