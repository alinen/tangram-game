<html>
<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
}

#container {
  position: absolute;
  width: 100vw;
  height: 100vh;
}

#svgObject, #overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

#overlay {
  pointer-events: none; /* clicks go to SVG */
}
</style>
<body>

<div id="container">
  <object id="svgObject" 
          data="puzzle-rocket.svg" 
          type="image/svg+xml" 
          preserveAspectRatio="xMidYMid meet"
          onload="start()">
  </object>
  <canvas id="overlay"></canvas>
</div>

<script>
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
var svg = null;

var gameOverMessage = "You win!";
var gameOver = false;

var selectedPiece = null;
var selectedOffsetX = 0;
var selectedOffsetY = 0;
var puzzlePieces = [];

class PuzzlePiece
{
  constructor(svgElement)
  {
    this.el = svgElement;
    this.bbox = this.el.getBBox();
    this.startx = this.el.getBoundingClientRect().x;
    this.starty = this.el.getBoundingClientRect().y;

    //console.log("puzzle piece:" + this.el.id);
    //console.log(`puzzle bbox: ${this.bbox.x} ${this.bbox.y} ${this.bbox.width} ${this.bbox.height}`);
  }

  translate(x, y) {
    x = x - this.bbox.x;
    y = y - this.bbox.y;
    var attrval =  `translate(${x} ${y})`;
    this.el.setAttribute("transform", attrval);
  }

  intersects(pos) {
    const bbox = this.el.getBoundingClientRect();
    if (pos.x >= bbox.x && pos.x <= bbox.x + bbox.width &&
        pos.y >= bbox.y && pos.y <= bbox.y + bbox.height) {
          return true;
    }
    return false;
  }
}

function canvas2svg(px, py) {
  var vb = svg.viewBox.baseVal;
  x = px * vb.width / canvas.width;
  y = py * vb.height / canvas.height;
  return {x: x, y: y};
}

function svg2canvas(px, py) {
  var vb = svg.viewBox.baseVal;
  x = px * canvas.width / vb.width;
  y = py * canvas.height / vb.height;
  return {x: x, y: y};
}

function mouseClick(e) {
  var clickPos = {x: e.clientX, y: e.clientY};

  var selected = null;
  for (var piece of puzzlePieces) {
    if (piece.intersects(clickPos)) {
      selected = piece;
      break;
    }
  }

  if (selected)
  {
    console.log("CLICK ", selected.el.id);
    selectedOffsetX = e.clientX - selected.el.getBoundingClientRect().x;
    selectedOffsetY = e.clientX - selected.el.getBoundingClientRect().y;
  }
  selectedPiece = selected;
}

function mouseMove(e) {
  if (selectedPiece == null) return;

  // convert from client coordinates to SVG viewport coordinates
  var vb = svg.viewBox.baseVal;
  var factor = (vb.height / vb.width) * canvas.width;
  var x = (e.clientX / canvas.width) * vb.width;
  var y = (e.clientY - (canvas.height - factor) / 2) / factor * vb.height;
  selectedPiece.translate(x, y); //piece.startx, piece.starty);
}

function start() {
  console.log("start");
  const obj = document.getElementById("svgObject");
  const svgDoc = obj.contentDocument;
  if (!svgDoc) {
    console.logError("Error: No SVG document found.");
    return;
  }

  svg = svgDoc.querySelector("svg");
  svg.addEventListener("mousemove", e => { mouseMove(e); });
  svg.addEventListener("click", e => { mouseClick(e); });

  //const width = svg.viewBox.baseVal.width;
  //const height = svg.viewBox.baseVal.height;
  //Math.floor(Math.random() * 2); 

  var idx = 0; 
  var x = 200;
  var y = 25;
  var maxsize = 0;
  const puzzleLayer = svgDoc.getElementById("PuzzleLayer");
  for (const el of puzzleLayer.children) {
    var piece = new PuzzlePiece(el);
    piece.translate(x, y);
    puzzlePieces.push(piece);
    //console.log(`${el.id} ${i} ${j} ${x} ${y}`);

    x = x + piece.bbox.width + 10;
    if (maxsize < piece.bbox.height) maxsize = piece.bbox.height;

    idx = idx + 1;
    if (idx % 4 == 0) {
      y = y + maxsize + 10;
      x = 200;
    }
  }
}

function resize() {
  canvas.width  = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  draw();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (gameOver)
  {
    ctx.font = "64px Arial";
    ctx.textAlign = "center";
    ctx.lineWidth = 2;
    ctx.fillStyle = "red";
    ctx.strokeStyle = "black";
    ctx.fillText(gameOverMessage, canvas.width/2, canvas.height/2);
    ctx.strokeText(gameOverMessage, canvas.width/2, canvas.height/2);
  }
}

window.addEventListener("resize", resize);
resize();
</script>


</body>
</html>